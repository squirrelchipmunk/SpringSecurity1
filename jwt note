jwt : json web token
세션의 문제점을 해결하기 위한 기술



<----- 세션 ----->
- 웹 브라우저의 최초 요청 시 응답(http header)을 받으면 쿠키에 세션 ID가 자동으로 저장됨. 이후 요청부터는 요청에 세션 ID를 헤더에 포함.
서버는 받은 요청의 세션 ID를 목록에서 확인하고 없으면 목록에 추가/ 있으면 이전에 방문했음을 알 수 있음.

- 세션 삭제 : 서버에서 제거 / 세션 시간 경과 / 사용자가 브라우저 닫으면

- 로그인 요청
사용자 요청 -> 서버 -> 세션 저장소에 세션ID 추가 -> 응답 헤더에 세션 ID 포함 -> 웹브라우저에 세션 ID 저장 
  -> 로그인 요청 -> 서버가 DB에서 아이디 비밀번호 확인 후 해당 세션 ID의 저장소에 USER 정보를 저장
  -> 메인페이지로 이동 -> 유저 정보 요청(세션ID 포함) -> 서버가 해당 세션 ID의 저장소에 USER 정보가 있는지 확인
  -> DB에서 조회하여 응답
  
- 단점
1.동시 접속자 수가 많으면 많은 서버가 필요함 -> 부하 분산이 필요(로드 밸런싱) -> 이때 세션 ID가 저장되지 않은 서버로 요청되면 로그인 정보가 사라지는 문제

해결 방법
세션이 저장되면 같은 서버만 사용하도록 하는 방법
세션 간에 복제하는 방법
DB에 값을 저장하는 방법(속도 문제)
메모리 공유 서버 사용(빠른 속도) -> redis


<----- TCP ----->
- OSI 7계층
응용계층 : 프로그램
표현계층 : 암호화
세션계층 : 인증 체크
전송계층 : TCP/UDP 결정
네트워크계층 : IP
-----WAN-------
-----LAN-------
데이터링크계층 : 라우팅
물리계층 : 전기선 광케이블

- TCP : 신뢰성 있는 통신. ACK를 이용해 잘 보내졌는지 확인. 느린 속도. (WEB) 
- UDP : 신뢰성 없는 통신. 빠른 속도. 전화/동영상 (사람이 이해 가능한)


<----- CIA ----->
C: 기밀성 : 암호화
I: 무결성
A: 가용성


<----- RSA 암호화----->
공개키(public) / 개인키(private)

상대방(B)의 공개키로 암호화해서 보내기 : B가 자신의 개인키로 복호화 가능 (기밀성, 암호화)
자신(A)의 개인키로 암호화해서 보내기 : A의 공개키로 복호화 가능 -> 보낸 사람이 A (무결성, 전자서명)

- 인증과 암호화 동시에 해결하는 방법
A ---------------> B 
A개인키(B공개키(~~~)) 


<----- RFC 문서 ----->
- 약속된 규칙의 문서 -> HTTP 프로토콜  -------> WEB
- 새로운 규칙이 추가되려면 동의를 얻어야 함
- RFC 7519 : JWT


<----- JSON 웹 토큰 ----->
- 당사자간 정보를 JSON 객체로 안전하게 전송학 위한 개방형 표준
- 디지털 서명된 토큰★★★ : 정보의 무결성
- HMAC, RSA, ECDSA

- Base64url

- 구조
xxxxx.yyyyy.zzzzz
┌ header : 사용 중인 서명 알고리즘, 토큰 유형
│ payload : 등록된 클레임 -> 필수는 아니지만 권장되는 클레임 집합 / 개인 클레임
└ signature : 인코딩 된 헤더 + 인코딩 된 페이로드 + 키 암호화

- 사용 예(HMAC)
클라이언트 로그인 요청(username, password)
-> 서버는 세션이 아니라 jwt를 만듦
-> header:HS256 , payload:{username:abc}, signature: header+payload+secret key) HS256
-> header, payload, signature 각각을 base64url 인코딩하여 클라이언트에 돌려준다
-> 클라이언트의 로컬 스토리지 같은 영역에 저장
-> 개인 정보 요청(jwt)
-> 서버에서 토큰 검증 : 받은 토큰에서 header+payload+secret key로 암호화해서 토큰의 signature와 일치하는지 비교

( HMAC : 시크릿키를 포함한 암호화 방법 )

- RSA 사용하는 방법
header, payload를 서버의 개인키로 암호화해서 클라이언트에 저장
이후 클라이언트가 요청과 jwt을 같이 보내면 서버는 공개키로 복호화

- 토큰만 검증하면 되므로 세션의 문제점이 해결됨




